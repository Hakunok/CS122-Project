import pygame
import random
import math

# Initialize Pygame
pygame.init()

SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

class Player:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.radius = 10
        self.speed = 3
        self.health = 100
        self.weapons = []
        self.experience = 0
        self.level = 1
        
    def move(self, dx, dy):
        self.x = max(self.radius, min(SCREEN_WIDTH - self.radius, self.x + dx * self.speed))
        self.y = max(self.radius, min(SCREEN_HEIGHT - self.radius, self.y + dy * self.speed))
    
    def draw(self, screen):
        pygame.draw.circle(screen, (255, 255, 255), (int(self.x), int(self.y)), self.radius)

class Weapon:
    def __init__(self, player):
        self.player = player
        self.cooldown = 0
        self.cooldown_max = 30
        self.damage = 10
        self.projectiles = []
        
    def update(self):
        self.cooldown -= 1
        if self.cooldown <= 0:
            self.attack()
            self.cooldown = self.cooldown_max
            
        # Update projectiles
        for proj in self.projectiles[:]:
            proj.update()
            if proj.should_remove():
                self.projectiles.remove(proj)
    
    def draw(self, screen):
        for proj in self.projectiles:
            proj.draw(screen)

class Whip(Weapon):
    def __init__(self, player):
        super().__init__(player)
        self.cooldown_max = 60
        self.range = 50
        
    def attack(self):
        # Simple whip attack to the right
        self.projectiles.append(WhipProjectile(self.player.x + 20, self.player.y, self.damage))

class WhipProjectile:
    def __init__(self, x, y, damage):
        self.x = x
        self.y = y
        self.damage = damage
        self.lifetime = 10
        
    def update(self):
        self.lifetime -= 1
        
    def should_remove(self):
        return self.lifetime <= 0
        
    def draw(self, screen):
        pygame.draw.rect(screen, (255, 200, 0), (self.x, self.y - 5, 30, 10))

class Enemy:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.radius = 8
        self.speed = 1
        self.health = 20
        self.color = (255, 0, 0)
        
    def update(self, player):
        # Simple movement towards player
        dx = player.x - self.x
        dy = player.y - self.y
        dist = max(0.1, math.sqrt(dx*dx + dy*dy))
        self.x += (dx / dist) * self.speed
        self.y += (dy / dist) * self.speed
        
    def draw(self, screen):
        pygame.draw.circle(screen, self.color, (int(self.x), int(self.y)), self.radius)

class ExperienceGem:
    def __init__(self, x, y, value=1):
        self.x = x
        self.y = y
        self.radius = 3
        self.value = value
        self.color = (0, 255, 255)
        
    def draw(self, screen):
        pygame.draw.circle(screen, self.color, (int(self.x), int(self.y)), self.radius)

class Game:
    def __init__(self):
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        self.clock = pygame.time.Clock()
        self.running = True
        self.player = Player(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2)
        self.enemies = []
        self.experience_gems = []
        self.spawn_timer = 0
        self.font = pygame.font.Font(None, 36)
        
        # Give player starting weapon
        self.player.weapons.append(Whip(self.player))
    
    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    self.running = False
    
    def update(self):
        # Player movement
        keys = pygame.key.get_pressed()
        dx, dy = 0, 0
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            dx -= 1
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            dx += 1
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            dy -= 1
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            dy += 1
            
        if dx != 0 or dy != 0:
            # Normalize diagonal movement
            length = math.sqrt(dx*dx + dy*dy)
            self.player.move(dx/length, dy/length)
        
        # Update weapons
        for weapon in self.player.weapons:
            weapon.update()
        
        # Spawn enemies
        self.spawn_timer += 1
        if self.spawn_timer >= 60:  # Spawn every second
            self.spawn_enemy()
            self.spawn_timer = 0
        
        # Update enemies
        for enemy in self.enemies[:]:
            enemy.update(self.player)
            
            # Check collision with player
            dist = math.sqrt((enemy.x - self.player.x)**2 + (enemy.y - self.player.y)**2)
            if dist < enemy.radius + self.player.radius:
                self.player.health -= 1
                self.enemies.remove(enemy)
                continue
                
            # Check collision with projectiles
            for weapon in self.player.weapons:
                for proj in weapon.projectiles[:]:
                    proj_dist = math.sqrt((enemy.x - proj.x)**2 + (enemy.y - proj.y)**2)
                    if proj_dist < enemy.radius + 5:  # arbitrary projectile size
                        enemy.health -= proj.damage
                        if enemy.health <= 0:
                            self.enemies.remove(enemy)
                            self.spawn_experience(enemy.x, enemy.y)
                            if proj in weapon.projectiles:
                                weapon.projectiles.remove(proj)
                        break
        
        # Check experience gem collection
        for gem in self.experience_gems[:]:
            dist = math.sqrt((gem.x - self.player.x)**2 + (gem.y - self.player.y)**2)
            if dist < gem.radius + self.player.radius:
                self.player.experience += gem.value
                self.experience_gems.remove(gem)
    
    def spawn_enemy(self):
        # Spawn from outside the screen
        side = random.randint(0, 3)
        if side == 0:  # top
            x = random.randint(0, SCREEN_WIDTH)
            y = -20
        elif side == 1:  # right
            x = SCREEN_WIDTH + 20
            y = random.randint(0, SCREEN_HEIGHT)
        elif side == 2:  # bottom
            x = random.randint(0, SCREEN_WIDTH)
            y = SCREEN_HEIGHT + 20
        else:  # left
            x = -20
            y = random.randint(0, SCREEN_HEIGHT)
            
        self.enemies.append(Enemy(x, y))
    
    def spawn_experience(self, x, y):
        self.experience_gems.append(ExperienceGem(x, y))
    
    def draw(self):
        self.screen.fill((0, 0, 0))
        
        # Draw experience gems
        for gem in self.experience_gems:
            gem.draw(self.screen)
        
        # Draw weapons/projectiles
        for weapon in self.player.weapons:
            weapon.draw(self.screen)
        
        # Draw enemies
        for enemy in self.enemies:
            enemy.draw(self.screen)
        
        # Draw player
        self.player.draw(self.screen)
        
        # Draw UI
        level_text = self.font.render(f"Level: {self.player.level}", True, (255, 255, 255))
        exp_text = self.font.render(f"EXP: {self.player.experience}", True, (255, 255, 255))
        health_text = self.font.render(f"Health: {self.player.health}", True, (255, 255, 255))
        
        self.screen.blit(level_text, (10, 10))
        self.screen.blit(exp_text, (10, 50))
        self.screen.blit(health_text, (10, 90))
        
        pygame.display.flip()
    
    def run(self):
        while self.running:
            self.handle_events()
            self.update()
            self.draw()
            self.clock.tick(FPS)

if __name__ == "__main__":
    game = Game()
    game.run()
    pygame.quit()
